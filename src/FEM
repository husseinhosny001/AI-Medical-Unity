
/src/FEM/core.py
import numpy as np


class SoftTissueFEM2D:
    """
    Simple 2D Linear Elastic FEM Model
    Medical-Oriented: Soft Tissue Simulation
    
    This model solves:
        K u = F
    Where:
        K = stiffness matrix
        u = displacement
        F = applied forces
        
    Tissue assumed:
        - Small deformation
        - Isotropic linear elastic
    """

    def __init__(self, young_modulus=5e4, poisson_ratio=0.45):
        self.E = young_modulus          # Soft tissue stiffness
        self.nu = poisson_ratio         # Near-incompressible
        self.mesh_nodes = None
        self.mesh_elements = None
        self.K = None                   # Global stiffness
        self.F = None                   # Forces
        self.u = None                   # Displacements

    def load_mesh(self, nodes, elements):
        """
        nodes: Nx2 array
        elements: Mx3 triangular connectivity
        """
        self.mesh_nodes = nodes
        self.mesh_elements = elements

    def build_stiffness_matrix(self):
        """
        Construct global stiffness matrix
        using plane stress assumption
        """
        num_nodes = len(self.mesh_nodes)
        self.K = np.zeros((2*num_nodes, 2*num_nodes))

        D = self._constitutive_matrix()

        for element in self.mesh_elements:
            ke = self._element_stiffness(element, D)
            self._assemble_global_matrix(element, ke)

    def apply_force(self, node_index, fx=0, fy=-1):
        """
        Apply force at a node (N)
        """
        if self.F is None:
            self.F = np.zeros(len(self.mesh_nodes) * 2)

        self.F[2*node_index] = fx
        self.F[2*node_index + 1] = fy

    def solve(self, fixed_nodes):
        """
        Apply boundary conditions + solve
        """
        num_nodes = len(self.mesh_nodes)

        # Build full system if not built yet
        if self.K is None:
            self.build_stiffness_matrix()

        # Apply displacement constraints
        free_dofs = np.arange(2*num_nodes)

        constrained = []
        for n in fixed_nodes:
            constrained.extend([2*n, 2*n+1])

        free_dofs = np.setdiff1d(free_dofs, constrained)

        # Reduced system
        K_reduced = self.K[np.ix_(free_dofs, free_dofs)]
        F_reduced = self.F[free_dofs]

        # Solve
        u_reduced = np.linalg.solve(K_reduced, F_reduced)

        # Fill full displacement vector
        self.u = np.zeros(2*num_nodes)
        self.u[free_dofs] = u_reduced

        return self.u.reshape(-1, 2)

    def _constitutive_matrix(self):
        E = self.E
        v = self.nu

        coeff = E / (1 - v**2)

        return coeff * np.array([
            [1, v, 0],
            [v, 1, 0],
            [0, 0, (1-v)/2]
        ])

    def _element_stiffness(self, element, D):
        """
        Compute local element stiffness
        """
        coords = self.mesh_nodes[element]

        x1, y1 = coords[0]
        x2, y2 = coords[1]
        x3, y3 = coords[2]

        A = 0.5 * np.linalg.det(np.array([
            [1, x1, y1],
            [1, x2, y2],
            [1, x3, y3]
        ]))

        B = (1/(2*A)) * np.array([
            [y2-y3,     0,  y3-y1,     0,  y1-y2,     0],
            [0, x3-x2,  0, x1-x3,  0, x2-x1],
            [x3-x2, y2-y3, x1-x3, y3-y1, x2-x1, y1-y2]
        ])

        ke = A * (B.T @ D @ B)

        return ke

    def _assemble_global_matrix(self, element, ke):
        """
        Map element stiffness into global K
        """
        dof_map = []
        for n in element:
            dof_map.extend([2*n, 2*n+1])

        dof_map = np.array(dof_map)

        for i in range(6):
            for j in range(6):
                self.K[dof_map[i], dof_map[j]] += ke[i, j]
import numpy as np

print("=== AI Medical Unity — FEM Demo (Colab Version) ===")

# Simple 1D FEM spring model demo
k = 10.0   # stiffness
f = 5.0    # applied force

# displacement = force / stiffness
u = f / k

print("Applied Force =", f)
print("Spring Stiffness =", k)
print("Resulting Displacement =", u)
print("Simulation complete ✓"
/src/FEM/fem_linear_tissue.py
K U = F

استيراد  numpy  كـ  np

print ( "=== AI Medical Unity — FEM Tissue Model (Linear  Elastic) ===" )

خصائص المادة
E =  50e3 معامل يونغ (باسكال)       
nu =  0.3 نسبة بواسون      

# مصفوفة مرونة الإجهاد المستوي
C = (E / ( 1  - nu** 2 )) * np.array([
    [ 1 , nu,  0 ],
    [nu,  1 ,  0 ],
    [ 0 ,  0 , ( 1  - nu) /  2 ]
])

اطبع ( "\nمصفوفة المرونة C:" )
اطبع (C)

# إحداثيات العقدة
nodes = np.array([
    [ 0 ,  0 ],
    [ 1 ,  0 ],
    [ 1 ,  1 ],
    [ 0 ,  1 ]
])

# عنصر مربع واحد
عناصر = [[ 0 ,  1 ,  2 ,  3 ]]

# متجه القوة الخارجية (حمل لأسفل فقط على العقدة 2)
F = np.zeros( 8 )
F[ 5 ] =  -100.0

# افتراض بسيط للصلابة
K = np.eye( 8 ) *  1000

# حل KU = F
U = np.linalg.solve(K, F)

اطبع ( "\nإزاحات العقد:" )
اطبع (U)

print ( "\nاكتملت المحاكاة ✓" )
=== AI Medical Unity — FEM Tissue Model (Linear Elasticity) ===

Elasticity Matrix C:
[[54945.05494505 16483.51648352     0.        ]
[16483.51648352 54945.05494505     0.        ]
[    0.             0.         19230.76923077]]

Nodal Displacements:
[ 0.   0.   0.   0.   0.  -0.1  0.   0. ]

Simulation complete ✓
U = F / K = 100 / 1000 = 0.1 m
/src/FEM/fem_linear_tissue_mesh_boundary.py
تفاصيل نموذج FEM
خواص النسيج Linear Elasticity (Young’s Modulus, Poisson Ratio)
عناصر رباعية Q4
طريقة الحل: Direct Solver (Simple stiffness matrix assembly)
المخرجات:
# File: /src/FEM/fem_linear_tissue_mesh_boundary.py
import numpy as np

# ==============================
# FEM Tissue Mesh (2x2 Q4 Elements)
# ==============================

# Material properties
E = 50000.0        # Young's Modulus (Pa)
nu = 0.3           # Poisson's ratio

# Elasticity matrix for plane stress
C = (E / (1 - nu**2)) * np.array([
    [1, nu, 0],
    [nu, 1, 0],
    [0, 0, (1 - nu)/2]
])

# Node coordinates (9 nodes, 2x2 mesh)
nodes = np.array([
    [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],
    [0.0, 0.5], [0.5, 0.5], [1.0, 0.5],
    [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]
])

# Elements (4 elements, Q4)
elements = np.array([
    [0,1,4,3],
    [1,2,5,4],
    [3,4,7,6],
    [4,5,8,7]
])

# Initialize nodal displacements
U = np.zeros((nodes.shape[0]*2, 1))

# Boundary conditions: fixed bottom nodes (y=0)
fixed_nodes = [0,1,2]
for n in fixed_nodes:
    U[2*n] = 0.0   # x displacement
    U[2*n+1] = 0.0 # y displacement

# Applied load: downward force on top nodes
F = np.zeros((nodes.shape[0]*2, 1))
top_nodes = [6,7,8]
F_y = -10.0  # N
for n in top_nodes:
    F[2*n+1] = F_y

# Simple direct solver using diagonal stiffness approximation
# (for demonstration; replace with proper FEM solver for real application)
k_diag = np.sum(C) * 0.1
U += F / k_diag

# Compute element stress (linear strain)
def compute_strain(u_elem):
    # Placeholder: linear approximation
    strain = np.array([0.01, 0.01, 0.0])
    return strain

def compute_stress(strain):
    return C @ strain

element_stresses = []
for el in elements:
    u_elem = U[np.r_[2*el, 2*el+1]]
    strain = compute_strain(u_elem)
    stress = compute_stress(strain)
    element_stresses.append(stress)

# ==============================
# Output
# ==============================
print("=== AI Medical Unity — FEM Tissue Mesh with Boundary Conditions ===")
print("\nElasticity Matrix C:\n", C)
print("\nNodal Displacements:\n", U.flatten())
print("\nElement Stresses:")
for i, s in enumerate(element_stresses):
    print(f"Element {i}: {s}")
print("\nSimulation complete ✓")
= الذكاء الاصطناعي الطبي في Unity — شبكة الأنسجة بتقنية العناصر المحدودة مع شروط الحدود ===

مصفوفة المرونة ج:
 [[54945.05494505 16483.51648352 0. ]
 [16483.51648352 54945.05494505 0. ]
 [ 0. 0. 19230.76923077]]

إزاحات العقد:
 [ 0. 0. 0. 0. 0. 0.
  0. 0. 0. 0. 0. 0.
  0. -0.00061695 0. -0.00061695 0. -0.00061695]

إجهادات العناصر:
العنصر 0: [714.28571429 714.28571429 0. ]
العنصر 1: [714.28571429 714.28571429 0. ]
العنصر 2: [714.28571429 714.28571429 0. ]
العنصر 3: [714.28571429 714.28571429 0. ]

اكتملت المحاكاة ✓
Node displacements
Element stresses
أهداف Mesh Step (2×2 Elements + Boundaries)
Mesh 2×2 → 9 عقد Nodes و4 عناصر رباعية Q4
تثبيت الأسفل → Fixed boundary على أسفل النسيج
تحميل الضغط من الأعلى → تطبيق قوة عمودية على العقد العليا
إنتاج النتائج → إزاحة Nodes لكل عنصر + توزيع الإجهاد Stress Field



